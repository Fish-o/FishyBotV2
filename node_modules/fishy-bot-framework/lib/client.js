"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FishyClient = void 0;
const discord_js_1 = require("discord.js");
const types_1 = require("./types");
const fs = __importStar(require("fs"));
const path_1 = require("path");
const Interaction_1 = require("./structures/Interaction");
const axios_1 = __importDefault(require("axios"));
const ApplicationCommandCompare_1 = require("./utils/ApplicationCommandCompare");
const Embeds_1 = require("./utils/Embeds");
const mongoose_1 = __importDefault(require("mongoose"));
// The main client!
class FishyClient extends discord_js_1.Client {
    constructor(options, client_options) {
        super(client_options);
        this.commands = new discord_js_1.Collection();
        this.categories = new discord_js_1.Collection();
        this.fishy_options = options;
        // Checking for things
        if (!options.token)
            throw Error("You must specify a token");
        if (!options.db_uri && !options.disable_db_connect)
            throw Error("You must specify a database uri");
        if (!options.guild_model && !options.disable_db_connect)
            throw Error("You must specify a mongoose guild model");
        if (!options.guild_model.schema.path("id") && !options.disable_db_connect)
            throw Error("The mongoose model needs the 'id' path as a String");
        if (!options.guild_model.schema.path("settings") && !options.disable_db_connect)
            throw Error("The mongoose model needs the 'settings' path as a Map");
        //if (!options.event_array && !options.event_dir) throw Error("You must specify an event directory or event array");
        if (!options.cmd_array && !options.cmd_dir)
            throw Error("You must specify a command directory or command array");
        this.token = options.token;
        this.GuildModel = options.guild_model;
        //Loading commands and events
        if (!options.disable_load_on_construct)
            this.load();
    }
    // Loads the events from a given event_dir
    load_events(directory) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                if (directory) {
                    fs.readdir(directory, (err, files) => {
                        if (err)
                            return;
                        files.forEach((file, index, array) => {
                            const event = require(`${directory}/${file}`);
                            if (Object.keys(discord_js_1.Constants.Events).includes(event.trigger.toUpperCase()) ||
                                Object.values(discord_js_1.Constants.Events)
                                    .map((v) => v.toLowerCase())
                                    .includes(event.trigger.toLowerCase())) {
                                this.on(event.trigger, event.run.bind(null, this));
                            }
                            else {
                                // @ts-ignore
                                this.ws.on(event.trigger, event.run.bind(null, this));
                            }
                            if (index === array.length - 1)
                                resolve(true);
                        });
                    });
                }
                else {
                    resolve(false);
                }
            });
        });
    }
    // Loads the commands from a given cmd_dir
    load_commands(directory) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                if (directory) {
                    try {
                        const dirs = yield fs.promises.readdir(directory);
                        // Go through all the subdirecoties (categories)
                        dirs.forEach((dir, dir_index, dir_array) => __awaiter(this, void 0, void 0, function* () {
                            var _a;
                            const category_path = path_1.join(directory, dir);
                            let files = yield fs.promises.readdir(category_path);
                            console.log(files);
                            if (!files)
                                return;
                            // Find a the index file for a category
                            // That file says what the category does and that kind of stuff
                            let index_path = files.find((file) => file.startsWith("index.") && !file.endsWith(".d.ts"));
                            let category = undefined;
                            // Create a anew category if an index file was found
                            if (index_path) {
                                category = require(path_1.join(process.cwd(), category_path, index_path));
                                if (category) {
                                    category.commands = (_a = category.commands) !== null && _a !== void 0 ? _a : [];
                                    this.categories.set(category.name, category);
                                }
                            }
                            // Go through all the files in the direcory
                            files.forEach((file, file_index, file_array) => {
                                // Ignore all the non js/ts files, and the index file
                                if ((file.endsWith(".js") || file.endsWith(".ts")) &&
                                    !file.startsWith("index.") &&
                                    !file.endsWith(".d.ts")) {
                                    let command_path = path_1.join(process.cwd(), category_path, file);
                                    let new_command = require(command_path);
                                    // If the command doesnt have a given category, make the directory name its category
                                    if (!new_command.config.category) {
                                        new_command.config.category = dir;
                                    }
                                    // Check if the category already exists, and doesnt include the command already
                                    if (this.categories.has(new_command.config.category) &&
                                        !this.categories.get(new_command.config.category).commands.includes(new_command.config.name)) {
                                        let old_category = this.categories.get(new_command.config.category);
                                        old_category.commands.push(new_command.config.name);
                                        this.categories.set(new_command.config.category, old_category);
                                    }
                                    // Adds the command to the command Collection
                                    this.commands.set(new_command.config.name, new_command);
                                }
                                // If this was the last file, resolve
                                if (file_index === file_array.length - 1 && dir_index === dir_array.length - 1)
                                    resolve(true);
                            });
                        }));
                    }
                    catch (err) {
                        throw err;
                    }
                }
                else {
                    resolve(false);
                }
            }));
        });
    }
    // Loads interactions and updates them with discord if needed
    load_interactions(force_update, user_id) {
        return __awaiter(this, void 0, void 0, function* () {
            // Fetch discord user for getting the user id
            if (!user_id) {
                const userdataPath = `https://discord.com/api/v8/users/@me`;
                const userdata = yield axios_1.default.get(userdataPath, {
                    headers: { Authorization: `Bot ${this.token}` },
                });
                const user = userdata.data;
                user_id = user.id;
            }
            const SlashCommandsUrl = `https://discord.com/api/v8/applications/${user_id}/commands`;
            if (force_update) {
                this.commands.forEach((command) => {
                    const interaction = command.config.interaction_options;
                    axios_1.default
                        .post(SlashCommandsUrl, interaction, {
                        headers: { Authorization: `Bot ${this.token}` },
                    })
                        .catch((err) => {
                        console.log(`\nError:`);
                        console.log(err);
                        console.log(interaction);
                        console.log(err.response);
                    });
                });
            }
            else {
                const discordSlashCommandsData = yield axios_1.default.get(SlashCommandsUrl, {
                    headers: { Authorization: `Bot ${this.token}` },
                });
                const discordSlashCommands = discordSlashCommandsData.data;
                let botSlashCommands = this.commands.map((command) => command.config.interaction_options);
                let discord_done = [];
                botSlashCommands.forEach((botSlashCommand) => {
                    let discord_command = discordSlashCommands.find((cmd) => cmd.name == botSlashCommand.name);
                    if (!discord_command)
                        return axios_1.default
                            .post(`https://discord.com/api/v8/applications/${user_id}/commands`, botSlashCommand, {
                            headers: { Authorization: `Bot ${this.token}` },
                        })
                            .then((res) => console.log(`POST - ${res.status} Interaction: "${botSlashCommand.name}", `))
                            .catch((err) => {
                            console.log(err.response.config);
                            console.log(err.response.status);
                        });
                    discord_done.push(discord_command.id);
                    if (!ApplicationCommandCompare_1.ApplicationCommandCompare(botSlashCommand, discord_command))
                        return axios_1.default
                            .patch(`https://discord.com/api/v8/applications/${user_id}/commands/${discord_command.id}`, botSlashCommand, {
                            headers: { Authorization: `Bot ${this.token}` },
                        })
                            .then((res) => console.log(`PATCH - ${res.status} Interaction: "${botSlashCommand.name}", `))
                            .catch((err) => {
                            console.log(err.response.config);
                            console.log(err.response.status);
                        });
                });
                discordSlashCommands.forEach((cmd) => {
                    if (!discord_done.includes(cmd.id)) {
                        axios_1.default
                            .delete(`https://discord.com/api/v8/applications/${user_id}/commands/${cmd.id}`, {
                            headers: { Authorization: `Bot ${this.token}` },
                        })
                            .then((res) => console.log(`DELETE - ${res.status} Interaction: "${cmd.name}", `))
                            .catch((err) => {
                            console.log(err.response.config);
                            console.log(err.response.status);
                        });
                    }
                });
            }
        });
    }
    // Load the interaction command handler
    load_commandhandler() {
        return __awaiter(this, void 0, void 0, function* () {
            // @ts-ignore
            this.ws.on("INTERACTION_CREATE", (raw_interaction) => __awaiter(this, void 0, void 0, function* () {
                let interaction = new Interaction_1.Interaction(this, raw_interaction);
                let command = this.commands.get(interaction.name);
                if (!command) {
                    return interaction.sendSilent(`This interaction doesn't seem to exist, if you think this is a mistake, please contact ${this.fishy_options.author}`);
                }
                try {
                    yield command.run(this, interaction);
                }
                catch (err) {
                    let msg = `An error seems to have occured in the command: "${interaction.name}: \n\`\`\`${err}\`\`\``;
                    let embed = new Embeds_1.ErrorEmbed(`An error seems to have occured in the command: "${interaction.name}"`, `Reason: \n\`\`\`${err}\`\`\``);
                    if (interaction.response_used) {
                        interaction.send_webhook(embed);
                    }
                    else {
                        interaction.sendSilent(msg);
                    }
                }
                finally {
                }
            }));
        });
    }
    // Generate a help command
    help_command() {
        return __awaiter(this, void 0, void 0, function* () {
            let cmd = {
                config: {
                    bot_needed: false,
                    name: "help",
                    interaction_options: {
                        name: "help",
                        description: "View info about the bot commands and categories",
                        options: [
                            {
                                name: "help",
                                description: "Basic help command",
                                type: types_1.ApplicationCommandOptionType.SUB_COMMAND,
                            },
                            {
                                name: "category",
                                description: "To get help about a category",
                                type: types_1.ApplicationCommandOptionType.SUB_COMMAND_GROUP,
                                options: this.categories.map((category) => {
                                    var _a;
                                    console.log("in category");
                                    let obj = {
                                        name: category.name,
                                        description: category.description,
                                        type: types_1.ApplicationCommandOptionType.SUB_COMMAND,
                                        options: [
                                            {
                                                name: "command",
                                                description: "command to select",
                                                type: types_1.ApplicationCommandOptionType.STRING,
                                                choices: (_a = category.commands) === null || _a === void 0 ? void 0 : _a.map((command) => {
                                                    let choice = {
                                                        name: command,
                                                        value: "cmd_" + command,
                                                    };
                                                    return choice;
                                                }),
                                            },
                                        ],
                                    };
                                    return obj;
                                }),
                            },
                            {
                                name: "command",
                                description: "Get help about a specific command",
                                type: types_1.ApplicationCommandOptionType.SUB_COMMAND,
                                options: [
                                    {
                                        name: "name",
                                        description: "The command's name",
                                        required: true,
                                        type: types_1.ApplicationCommandOptionType.STRING,
                                    },
                                ],
                            },
                        ],
                    },
                },
                help: {
                    description: "Usefull for getting help about a category or command or the whole bot",
                    usage: "/help category info | /help command ping",
                },
                run: (client, interaction) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e, _f, _g;
                    let cmd_help = (cmd_name) => {
                        var _a, _b, _c;
                        let cmd = this.commands.get(cmd_name);
                        if (!cmd) {
                            cmd = this.commands.get(cmd_name.toLowerCase());
                            if (!cmd) {
                                cmd = this.commands.get(this.commands.keyArray()[this.commands
                                    .keyArray()
                                    .map((key) => key.toLowerCase())
                                    .indexOf(cmd_name.toLowerCase())]);
                                if (!cmd) {
                                    return new Embeds_1.ErrorEmbed("No command found");
                                }
                            }
                        }
                        if (cmd.help.help_embed)
                            return cmd.help.help_embed;
                        let embed = new discord_js_1.MessageEmbed().setAuthor(this.user.tag, this.user.displayAvatarURL(), `https://discord.com/oauth2/authorize?client_id=${this.user.id}&permissions=8&scope=bot%20applications.commands`);
                        if (cmd.help.color)
                            embed.setColor(cmd.help.color);
                        else
                            embed.setColor(((_a = this.categories.get(cmd.config.category || "")) === null || _a === void 0 ? void 0 : _a.help_embed_color) || "RANDOM");
                        if (cmd.help.title)
                            embed.setTitle(cmd.help.title);
                        else
                            embed.setTitle(`${cmd.config.name} - Command Help`);
                        embed.setDescription(`${cmd.help.description}
Usage: \`${cmd.help.usage}\`
User required perms: \`${((_b = cmd.config.user_perms) === null || _b === void 0 ? void 0 : _b.join(", ")) || "None"}\`
Bot user needed: \`${cmd.config.bot_needed}\`
`);
                        embed.setFooter(`bot perms: ${((_c = cmd.config.bot_perms) === null || _c === void 0 ? void 0 : _c.join(", ")) || "None"} `);
                        return embed;
                    };
                    let cat_help = (cat_name) => {
                        var _a, _b;
                        if (!cat_name)
                            return new Embeds_1.ErrorEmbed(`Category "${cat_name}" not found`);
                        let cat = this.categories.get(cat_name);
                        if (!cat) {
                            cat = this.categories.get(cat_name.toLowerCase());
                            if (!cat) {
                                cat = this.categories.get(this.categories.keyArray()[this.categories
                                    .keyArray()
                                    .map((key) => key.toLowerCase())
                                    .indexOf(cat_name.toLowerCase())]);
                                if (!cat) {
                                    return new Embeds_1.ErrorEmbed(`No category found for: "${cat_name}"`);
                                }
                            }
                        }
                        if (cat.help_embed)
                            return cat.help_embed;
                        let embed = new discord_js_1.MessageEmbed().setAuthor(this.user.tag, this.user.displayAvatarURL(), `https://discord.com/oauth2/authorize?client_id=${this.user.id}&permissions=8&scope=bot%20applications.commands`);
                        if (cat.help_embed_color)
                            embed.setColor(cat.help_embed_color);
                        else
                            embed.setColor("RANDOM");
                        if (cat.help_embed_title)
                            embed.setTitle(cat.help_embed_title);
                        else
                            embed.setTitle(`${cat.name} - Category Help`);
                        embed.setDescription(`${cat.description}

${(_b = (_a = cat.commands) === null || _a === void 0 ? void 0 : _a.map((command_name) => {
                            let cmd = this.commands.get(command_name);
                            if (cmd) {
                                return `**${command_name}** \`${cmd.help.description}\``;
                            }
                            return `**${command_name}**`;
                        })) === null || _b === void 0 ? void 0 : _b.join("\n")}
`);
                        return embed;
                    };
                    console.log(interaction.args);
                    if (interaction.args.find((arg) => arg.name == "category")) {
                        let cat_arg = interaction.args.find((arg) => arg.name == "category");
                        if ((_a = cat_arg === null || cat_arg === void 0 ? void 0 : cat_arg.options) === null || _a === void 0 ? void 0 : _a[0]) {
                            if ((_c = (_b = cat_arg.options[0].options) === null || _b === void 0 ? void 0 : _b[0].value) === null || _c === void 0 ? void 0 : _c.startsWith("cmd_")) {
                                let cmd_name = cat_arg.options[0].options[0].value.slice(4);
                                let cmd = this.commands.get(cmd_name);
                                if (!((_d = cmd === null || cmd === void 0 ? void 0 : cmd.config) === null || _d === void 0 ? void 0 : _d.name)) {
                                    return interaction.send(new Embeds_1.ErrorEmbed(`Command "${cmd_name}" not found`));
                                }
                                interaction.send(cmd_help(cmd_name));
                            }
                            else {
                                let cat_name = cat_arg.options[0].name;
                                interaction.send(cat_help(cat_name));
                            }
                        }
                    }
                    else if (((_g = (_f = (_e = interaction.args.find((arg) => arg.name == "command")) === null || _e === void 0 ? void 0 : _e.options) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.name) === "name") {
                        let cmd_name = interaction.args.find((arg) => arg.name == "command").options[0].value;
                        if (!cmd_name) {
                            return interaction.send(new Embeds_1.ErrorEmbed(`Command "${cmd_name}" not found`));
                        }
                        interaction.send(cmd_help(cmd_name));
                    }
                    else {
                    }
                }),
            };
            console.log(cmd);
            return cmd;
        });
    }
    // Connect to the mongo db database
    load_db() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                mongoose_1.default.connect(this.fishy_options.db_uri, { useNewUrlParser: true, useUnifiedTopology: true });
            }
            catch (err) {
                console.log(err);
                throw Error("Failed to connect to the MongoDB server: \n" + err);
            }
            finally {
                return;
            }
        });
    }
    // Load command :)
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const options = this.fishy_options;
            if (options.event_array) {
                options.event_array.forEach((event) => {
                    if (Object.keys(discord_js_1.Constants.Events).includes(event.trigger.toUpperCase()) ||
                        Object.values(discord_js_1.Constants.Events)
                            .map((v) => v.toLowerCase())
                            .includes(event.trigger.toLowerCase())) {
                        this.on(event.trigger, event.run.bind(null, this));
                    }
                    else {
                        // @ts-ignore
                        this.ws.on(event.trigger, event.run.bind(null, this));
                    }
                });
            }
            if (options.cmd_array) {
                options.cmd_array.forEach((new_command) => {
                    var _a;
                    new_command.config.category = (_a = new_command.config.category) !== null && _a !== void 0 ? _a : "debug";
                    if (this.categories.has(new_command.config.category) &&
                        !this.categories.get(new_command.config.category).commands.includes(new_command.config.name)) {
                        let old_category = this.categories.get(new_command.config.category);
                        old_category.commands.push(new_command.config.name);
                        this.categories.set(new_command.config.category, old_category);
                    }
                    this.commands.set(new_command.config.name, new_command);
                });
            }
            yield Promise.all([this.load_events(options.event_dir), this.load_commands(options.cmd_dir)]);
            if (!options.disable_help_command) {
                let help_cmd = yield this.help_command();
                this.commands.set(help_cmd.config.name, help_cmd);
            }
            if (!options.disable_interaction_load)
                yield this.load_interactions();
            if (!options.disable_command_handler)
                yield this.load_commandhandler();
            if (!options.disable_db_connect)
                yield this.load_db();
        });
    }
}
exports.FishyClient = FishyClient;
