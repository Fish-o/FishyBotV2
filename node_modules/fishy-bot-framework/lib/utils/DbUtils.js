"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.update = exports.fetch = void 0;
const discord_js_1 = require("discord.js");
const db_guild_cache = new discord_js_1.Collection();
const ttl = 5 * 60 * 1000;
const refresh_time = 20 * 1000;
function refresh(client, guild_id, options, count) {
    return __awaiter(this, void 0, void 0, function* () {
        let db_res = yield client.GuildModel.findOne({ id: guild_id });
        if (!db_res) {
            if (!client.fishy_options.disable_db_default_upsert && !(options === null || options === void 0 ? void 0 : options.disable_upsert)) {
                const new_model = new client.GuildModel({ id: guild_id });
                yield new_model.save();
                return yield refresh(client, guild_id, options, (count = 1));
            }
            else {
                throw Error(`Could not find the database document of "${guild_id}"`);
            }
        }
        let answer = { timestamp: Date.now(), data: db_res };
        db_guild_cache.set(guild_id, answer);
        return answer.data;
    });
}
function fetch(client, guild_id, options) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        if (!guild_id) {
            return;
        }
        if (!db_guild_cache.has(guild_id) || db_guild_cache.get(guild_id).timestamp + ttl > Date.now())
            return resolve(yield refresh(client, guild_id, options));
        else if (db_guild_cache.get(guild_id).timestamp + refresh_time > Date.now()) {
            resolve(db_guild_cache.get(guild_id));
            return yield refresh(client, guild_id, options);
        }
    }));
}
exports.fetch = fetch;
function update(client, guild_id, model) {
    return __awaiter(this, void 0, void 0, function* () {
        yield client.GuildModel.updateOne({ id: guild_id }, model);
        yield refresh(client, guild_id);
    });
}
exports.update = update;
