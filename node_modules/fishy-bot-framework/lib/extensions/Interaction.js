"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Interaction = void 0;
const types_1 = require("../types");
const axios_1 = __importDefault(require("axios"));
/*

{
  version: 1,
  type: 2,
  token: 'asdf'
  member: {
    user: {
      username: 'Fish',
      public_flags: 256,
      id: '325893549071663104',
      discriminator: '2455',
      avatar: '5a4e62341afa47f200bd8f0dcf759512'
    },
    roles: [
      '790969042851856425',
      '790969058710519808',
      '790969073210097715'
    ],
    premium_since: null,
    permissions: '2147483647',
    pending: false,
    nick: 'sdfgsdfg',
    mute: false,
    joined_at: '2020-09-06T13:18:35.776000+00:00',
    is_pending: false,
    deaf: false
  },
  id: '792502570592894986',
  guild_id: '752155794153406476',
  data: { name: 'help', id: '791272914905333760' },
  channel_id: '784438571620106311'
}
*/
class Interaction {
    constructor(client, raw_interaction) {
        this.client = client;
        this.raw_interaction = raw_interaction;
        this.data = raw_interaction.data;
        this.type = raw_interaction.type;
        this.id = raw_interaction.id;
        this.token = raw_interaction.token;
        this.guild_id = raw_interaction.guild_id;
        this.channel_id = raw_interaction.channel_id;
        this.raw_member = raw_interaction.member;
        this.name = this.data.name;
        this.args = this.data.options;
        this.response_used = false;
    }
    send(message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let embed;
            if (typeof message == "object") {
                embed = message;
                message = undefined;
            }
            let DATA = { content: message, embeds: embed ? [embed] : undefined };
            if (options) {
                DATA = Object.assign(DATA, options);
            }
            this.response_used = true;
            return yield axios_1.default.post(`https://discord.com/api/v8/interactions/${this.id}/${this.token}/callback`, {
                type: types_1.InteractionResponseType.ChannelMessageWithSource,
                data: DATA,
            });
        });
    }
    sendSilent(message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let DATA = { flags: 64, content: message };
            if (options) {
                DATA = Object.assign(DATA, options);
            }
            this.response_used = true;
            return yield axios_1.default.post(`https://discord.com/api/v8/interactions/${this.id}/${this.token}/callback`, {
                type: types_1.InteractionResponseType.ChannelMessageWithSource,
                data: DATA,
            });
        });
    }
    edit(message, options, message_id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!options) {
                options = {};
            }
            if (!message_id && options && typeof options == "string") {
                message_id = options;
                options = undefined;
            }
            if (typeof message !== "string" && typeof options !== "string") {
                if (!options) {
                    options = { embeds: [message] };
                }
                else if (options.embeds) {
                    options.embeds.push(message);
                }
                else {
                    options.embeds = [message];
                }
                message = "";
            }
            else if (typeof message == "string" && typeof options !== "string") {
                options.content = message;
            }
            if (!message_id) {
                message_id = "@original";
            }
            return yield axios_1.default.post(`https://discord.com/api/v8/webhooks/${this.client.user.id}/${this.token}/messages/${message_id}`, options);
        });
    }
    delete(message_id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!message_id) {
                message_id = "@original";
            }
            return yield axios_1.default.delete(`https://discord.com/api/v8/webhooks/${this.client.user.id}/${this.token}/messages/${message_id}`);
        });
    }
    send_webhook(message, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let embed;
            if (typeof message == "object") {
                embed = message;
                message = undefined;
            }
            let DATA = { content: message, embeds: embed ? [embed] : undefined };
            if (options) {
                DATA = Object.assign(DATA, options);
            }
            return yield axios_1.default.post(`https://discord.com/api/v8/webhooks/${this.client.user.id}/${this.token}`, DATA);
        });
    }
    get channel() {
        if (!this.channel_id)
            return undefined;
        return this.client.channels.cache.get(this.channel_id);
    }
    get guild() {
        if (!this.guild_id)
            return undefined;
        return this.client.guilds.cache.get(this.guild_id);
    }
    get member() {
        var _a, _b, _c;
        if (!((_b = (_a = this.raw_member) === null || _a === void 0 ? void 0 : _a.user) === null || _b === void 0 ? void 0 : _b.id))
            return undefined;
        return (_c = this.guild) === null || _c === void 0 ? void 0 : _c.members.cache.get(this.raw_member.user.id);
    }
}
exports.Interaction = Interaction;
